{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Custom RISC Architecture Documentation","text":"<p>Source Code Repo (private)</p>"},{"location":"#project-overview","title":"Project Overview","text":"<p>This project involves the architecture, design, and verification of a custom Single-Cycle RISC Processor. Designed from scratch in SystemVerilog, the core utilizes an Accumulator-based architecture to minimize instruction width to 9 bits while maintaining a 16-bit addressable memory space. Designed from python -&gt; C++ -&gt; SystemVerilog.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>9-Bit Custom ISA: Efficiently packs 4-bit opcodes and operands, maximizing code density.</li> <li>Accumulator Architecture: Implicit <code>R0</code> targeting to reduce instruction overhead.</li> <li>JLUT (Jump Look-Up Table): A decoupled logic unit handling 16-bit addressing within 9-bit constraints.</li> <li>Skip-on-Condition: Branching logic that decouples evaluation from execution, reducing control complexity.</li> </ul>"},{"location":"architecture/datapath/","title":"Datapath &amp; Components","text":"<p>The architecture is built around a centralized bus connecting the Control Unit, Register File, and ALU.</p>"},{"location":"architecture/datapath/#overview-of-the-datapath","title":"Overview of the Datapath:","text":"<pre><code>graph TD\n    %%--- Styling ---\n    classDef central fill:#f9f,stroke:#333,stroke-width:2px,color:black,font-weight:bold;\n    classDef component fill:#e1f5fe,stroke:#0277bd,stroke-width:1px,color:black;\n    classDef external fill:#fff3e0,stroke:#ef6c00,stroke-dasharray: 5 5,color:black;\n\n    %%--- External Inputs/Outputs ---\n    subgraph External Inputs\n        CLK(clk)\n        START(start)\n        RESET(reset)\n    end\n    DONE(done):::external\n\n    %%--- Center Component ---\n    TOP[TOP LEVEL&lt;br/&gt;Central Glue / Bus / Clock Coord]:::central\n\n    %%--- Left Side Components ---\n    subgraph memory controllers\n        JLUT[JLUT&lt;br/&gt;Jump Look Up Table]:::component\n        MEM3[(External Memory)]:::external\n        RF[RegFile&lt;br/&gt;Register File]:::component\n        MEM2[(External Memory)]:::external\n        IROM[InstROM&lt;br/&gt;Instruction ROM]:::component\n        MEM1[(External Memory)]:::external\n    end\n\n    %%--- Right Side Components ---\n    subgraph functional units\n        PC[PC&lt;br/&gt;Program Counter]:::component\n        ALU[ALU&lt;br/&gt;Arithmetic Logic Unit]:::component\n        CTRL[CTRL&lt;br/&gt;Control Decoder]:::component\n    end\n\n    %%--- Connections ---\n\n    %% External to TOP\n    CLK &amp; START &amp; RESET --&gt; TOP\n    TOP --&gt; DONE\n\n    %% PC connections\n    TOP -- \"...\" --&gt; PC\n    PC -- PC value --&gt; TOP\n\n    %% JLUT connections\n    TOP -- \"...\" --&gt; JLUT\n    JLUT -- jump address --&gt; TOP\n    JLUT &lt;--&gt; MEM3\n\n    %% RegFile connections\n    TOP -- \"...\" --&gt; RF\n    RF -- RdatA, RdatB --&gt; TOP\n    RF &lt;--&gt; MEM2\n\n    %% InstROM connections\n    TOP -- \"...\" --&gt; IROM\n    IROM &lt;--&gt; MEM1\n    IROM -- mach_code --&gt; TOP\n\n    %% ALU connections\n    TOP -- \"...\" --&gt; ALU\n    ALU -- result --&gt; TOP\n    ALU -- \"flags (zero, parity, carry, condition)\" --&gt; TOP\n\n    %% CTRL connections\n    TOP -- \"...\" --&gt; CTRL\n    CTRL -- control signals --&gt; TOP\n\n    %%--- Layout hints to force side-by-side ---\n    PC ~~~ IROM\n    JLUT ~~~ ALU\n    RF ~~~ CTRL</code></pre>"},{"location":"architecture/datapath/#top-level-connections","title":"Top-Level Connections","text":"<p>The <code>TopLevel</code> module coordinates the data flow between the Instruction ROM (<code>InstROM</code>) and the execution units.</p> <ul> <li>Program Counter (PC): Drives the address for the Instruction ROM.</li> <li>Instruction ROM: Outputs the 9-bit <code>mach_code</code> based on the PC.</li> <li>Control Decoder: Decodes the <code>mach_code</code> into control signals for the ALU and Memory.</li> <li>ALU: Executes arithmetic and logic operations based on the control signals and operands from the Register File.</li> <li>Register File: Provides the source operands for the ALU and receives results to be stored back.</li> <li>Jump Look-Up Table (JLUT): Provides target addresses for jump instructions, accessed by the Control Unit when needed.</li> <li>Data RAM: Stores data for load/store operations and intermediate results.</li> <li>MUX: Selects between different data sources based on control signals.</li> </ul>"},{"location":"architecture/datapath/#basic-components","title":"Basic Components:","text":"<pre><code>sequenceDiagram\n    autonumber\n\n    participant CTRL as Control Decoder\n    participant DM as Data Memory\n    participant RF as RegFile\n    participant ALU\n    participant JLUT\n    participant PC as Program Counter\n    participant IROM as Instruction ROM</code></pre>"},{"location":"architecture/datapath/#data-path-0_0000_0001-and-r1","title":"Data Path <code>0_0000_0001</code> (AND R1):","text":"<p>Control Decoder first decodes the <code>mach_code</code> from the Instruction ROM, which is <code>0_0000_0001</code> for the <code>AND R1</code> instruction. It decodes the <code>ALUop</code> (the ALU operation code), sends it to the ALU; and the <code>Ra</code> address (R1 in this case), sends it to the Register File to read the value of R1; <code>WenR</code> (write enable for the Register File) is set to 1, indicating that the result from the ALU should be written back to the Register File.</p> <p>Register File reads the value of R1 from its internal register array and sends it to the ALU as <code>RdatA</code>. Similarly, it reads the value of R0 (the accumulator) and sends it to the ALU as <code>RdatB</code>.</p> <p>The ALU performs the AND operation between <code>RdatA</code> (value of R1) and <code>RdatB</code> (value of R0, the accumulator), and sends the <code>result</code> back to the Register File to be stored in R0 (muxed); and output the <code>ALU_COND</code> (branch condition met) flag to 0 to the Program Counter to indicate that the next instruction should be executed sequentially. </p> <p>The Register File takes the <code>result</code> as the data to be written back to R0, and updates its internal register array accordingly (since <code>WenR</code> is set to 1). </p> <p>The Program controller, since the <code>ALU_COND</code> flag is 0, increments the <code>PC</code> by 1 to point to the next instruction in the Instruction ROM for the next cycle.</p> <p>The <code>mach_code</code> for the next instruction is fetched from the Instruction ROM based on the updated <code>PC</code>, and the process repeats for the next instruction.</p> <pre><code>sequenceDiagram\n    autonumber\n\n    %% Participants in your requested order\n    participant CTRL as Control Decoder\n    participant DM as Data Memory\n    participant RF as RegFile\n    participant ALU\n    participant JLUT\n    participant PC as Program Counter\n    participant IROM as Instruction ROM\n\n    Note over CTRL, IROM: Start of Cycle: Fetch &amp; Decode (AND R1)\n\n    IROM-&gt;&gt;CTRL: mach_code (0_0000_0001)\n\n    Note right of CTRL: Decodes ALUop (AND),&lt;br/&gt;Target R1, and WenR=1\n\n    CTRL-&gt;&gt;ALU: ALUop (AND)\n    CTRL-&gt;&gt;RF: Ra (R0), Rb (R1), WenR (1)\n\n    Note over RF, ALU: Operand Fetch\n    RF-&gt;&gt;ALU: RdatA (Value of R0/accumulator)\n    RF-&gt;&gt;ALU: RdatB (Value of R1) MUXED with Immediate\n\n    Note over ALU: Execute AND Operation\n    ALU-&gt;&gt;RF: Result (R0 &amp; R1), MUXED with DMem\n\n    Note left of RF: Writes Result into R0&lt;br/&gt;(Because WenR=1)\n\n    ALU-&gt;&gt;PC: ALU_COND (0)\n\n    Note right of PC: Branch condition not met.&lt;br/&gt;Standard Increment.\n    PC-&gt;&gt;PC: PC = PC + 1\n\n    Note over PC, IROM: Prepare Next Cycle\n    PC-&gt;&gt;IROM: Next Instruction Address</code></pre>"},{"location":"architecture/datapath/#data-path-10_00_0_1010-be-r10","title":"Data Path <code>10_00_0_1010</code> (BE R10):","text":"<p>Control Decorder decodes the <code>mach_code</code> for the <code>BE R10</code> instruction, which is <code>10_00_0_1010</code>. It sees it is a J-type instruction, therefore, it will send <code>ALUop</code> as subtraction, and <code>Ra</code> as R0,  <code>Rb</code> as R10, <code>ALU_branch</code> as <code>00</code> (indicate equal) to the ALU, which ask ALU to perform <code>R0 - R10</code>. The <code>WenR</code> is set to 0, indicating that the result from the ALU should not be written back to the Register File.</p> <p>Register File reads the value of R10 from its internal register array and sends it to the ALU as <code>RdatB</code>. Similarly, it reads the value of R0 (the accumulator) and sends it to the ALU as <code>RdatA</code>.</p> <p>Inside the ALU, it performs the subtraction, and set internal flags accordingly. It will then based on the the <code>ALU_branch</code> input to mux the correct flag (in this case, zero flag) to output as <code>ALU_Condition</code> flag to the Program Counter. </p> <p>The Program Counter checks the <code>ALU_Condition</code> flag. If it is 1 (indicating that R0 == R10), it will update the <code>PC</code> to <code>PC + 2</code> to skip the next instruction. If it is 0, it will simply increment the <code>PC</code> by 1 to point to the next instruction in the Instruction ROM for the next cycle.</p> <p>The <code>mach_code</code> for the next instruction is fetched from the Instruction ROM based on the updated <code>PC</code>, and the process repeats for the next instruction.</p> <pre><code>sequenceDiagram\n    autonumber\n\n    participant CTRL as Control Decoder\n    participant DM as Data Memory\n    participant RF as RegFile\n    participant ALU\n    participant JLUT\n    participant PC as Program Counter\n    participant IROM as Instruction ROM\n\n    %% 1. Fetch\n    IROM-&gt;&gt;CTRL: mach_code (10_00_0_1010)\n\n    %% 2. Decode &amp; Dispatch\n    %% CTRL tells ALU to subtract and check for equality (ALU_branch = 00)\n    CTRL-&gt;&gt;ALU: ALUop (SUB), ALU_branch (00)\n\n    %% CTRL tells RF which registers to read (Ra, Rb) and NOT to write back (WenR=0)\n    CTRL-&gt;&gt;RF: Ra (R0), Rb (R10), WenR (0)\n\n    %% 3. Operand Fetch\n    %% RF outputs the values. Note: User logic defined R10-&gt;RdatA and R0-&gt;RdatB\n    RF-&gt;&gt;ALU: RdatA (R0), RdatB (R10)\n\n    %% 4. Execution &amp; Flag Output\n    %% ALU performs subtraction (R0 - R10). If result is 0, Zero Flag is high.\n    ALU-&gt;&gt;PC: ALU_Condition (Zero Flag)\n\n    %% 5. PC Update Logic\n    %% This highlights the specific decision logic for this path\n    alt If ALU_Condition == 1 (Match)\n        PC-&gt;&gt;PC: PC = PC + 2 (Skip next)\n    else If ALU_Condition == 0 (No Match)\n        PC-&gt;&gt;PC: PC = PC + 1 (Next line)\n    end\n\n    %% 6. Prepare Next Cycle\n    PC-&gt;&gt;IROM: Next Instruction Address</code></pre>"},{"location":"architecture/datapath/#data-path-0_0101_0010-store-to-mem2-or-mem2-r0","title":"Data Path <code>0_0101_0010</code> (STORE to Mem[2], or Mem[2] = R0):","text":"<p>Control Decoder decodes the <code>mach_code</code> for the <code>STORE R2</code> instruction, which is <code>0_0101_0010</code>. It will send <code>Write Enable Dmem</code> as 1 to the Data Memory, and <code>Rb</code> as R2 to the Register File to read the value of R2, <code>DMemAddr</code> as 2, indicateing that the value in R0 should be stored into memory address 2. The <code>WenR</code> is set to 0, indicating that the result from the ALU should not be written back to the Register File.</p> <p>Register File reads the value of R2 from its internal register array and sends it to the Data memory and ALU as <code>RdatB</code>.</p> <p>The Data Memory receives the <code>Write Enable Dmem</code> signal, the <code>RdatB</code> from the Register File (which is the value of R2), and the <code>DMemAddr</code> (which is 2) to perform the store operation. It writes the value of R2 into memory address 2 (non blocking).</p> <p>The ALU is not involved in this instruction, it will output <code>ALU_Condition</code> flag as 0 to the Program Counter to indicate that the next instruction should be executed sequentially.</p> <p>The Program Counter increments by 1 to point to the next instruction in the Instruction ROM for the next cycle.</p> <pre><code>sequenceDiagram\n    autonumber\n\n    participant CTRL as Control Decoder\n    participant DM as Data Memory\n    participant RF as RegFile\n    participant ALU\n    participant JLUT\n    participant PC as Program Counter\n    participant IROM as Instruction ROM\n\n    %% 1. Fetch\n    IROM-&gt;&gt;CTRL: mach_code (0_0101_0010)\n\n    %% 2. Decode &amp; Control Signals\n    %% CTRL sets up Data Memory write\n    CTRL-&gt;&gt;DM: Write Enable Dmem (1), DMemAddr (2)\n\n    %% CTRL sets up Register Read (R2) but disables Register Write (WenR=0)\n    CTRL-&gt;&gt;RF: Rb (Addr R2), WenR (0)\n\n    %% 3. Data Transfer\n    %% RF sends value to DM (for storage) and ALU (unused connection)\n    RF-&gt;&gt;DM: RdatB (Value of R2)\n    RF-&gt;&gt;ALU: RdatB (Value of R2)\n\n    %% 4. Memory Write Action\n    Note right of DM: Writes Value of R2&lt;br/&gt;into Address 2\n\n    %% 5. ALU / PC Update\n    %% ALU is bypassed for logic, but still drives the condition line\n    ALU-&gt;&gt;PC: ALU_Condition (0)\n\n    Note right of PC: Sequential Execution\n    PC-&gt;&gt;PC: PC = PC + 1\n\n    %% 6. Prepare Next Cycle\n    PC-&gt;&gt;IROM: Next Instruction Address</code></pre>"},{"location":"architecture/datapath/#quartus-synthesis","title":"Quartus Synthesis:","text":""},{"location":"architecture/isa/","title":"Instruction Set Architecture (ISA)","text":"<ul> <li>9 bits instruction width</li> <li>2 bits for Type</li> <li>4 bits for Opcode</li> <li>3 bits for Operands (registers or immediate values)</li> </ul> <p>therefore, this architecture supports 0-15 for immediate value, R0-R15 registers (registers are 8 bits wide).   - R0 is the implicit accumulator register, and is the default destination;   - R1-R15 are general-purpose registers that can be used for various operations.</p> <p>It supports R-Type (Register), I-Type (Immediate), and J-Type (Jump) formats.</p>"},{"location":"architecture/isa/#opcode-map","title":"Opcode Map","text":"NAME TYPE BIT BREAKDOWN EXAMPLE NOTES AND R <code>0_0000_XXXX</code> <code>AND R1</code> \u2192 <code>0_0000_0001</code> \u2192 <code>R0 = R0 &amp; R1</code> Performs a logical bitwise and on R0 and the inputted operand register and puts the result in R0 OR R <code>0_0001_XXXX</code> <code>OR R5</code> \u2192 <code>0_0001_0101</code> \u2192 <code>R0 = R0 \\| R5</code> Performs a logical bitwise or on R0 and the inputted operand register and puts the result in R0 ADD R <code>0_0010_XXXX</code> <code>ADD R3</code> \u2192 <code>0_0010_0011</code> \u2192 <code>R0 = R0 + R3</code> Adds value in R0 and value in inputted operand register and puts the result into R0 SUB R <code>0_0011_XXXX</code> <code>SUB R8</code> \u2192 <code>0_0011_1000</code> \u2192 <code>R0 = R0 - R8</code> Subtracts value in R0 from the value in inputted operand register and puts the result into R0 LOAD R <code>0_0100_XXXX</code> <code>LOAD R6</code> \u2192 <code>0_0100_0110</code> \u2192 <code>R0 = MEM[R6]</code> Loads the memory that is in the specified operand register into R0 STORE R <code>0_0101_XXXX</code> <code>STORE R2</code> \u2192 <code>0_0101_0010</code> \u2192 <code>MEM[R2] = R0</code> Store the results of what is in R0 into the memory of the inputted operand register NOT R <code>0_0110_XXXX</code> <code>NOT R9</code> \u2192 <code>0_0110_1001</code> \u2192 <code>R9 = ~R9</code> Performs a logical bitwise not on the inputted operand register and puts the result in R0 MOV R <code>0_0111_XXXX</code> <code>MOV R2</code> \u2192 <code>0_0111_0010</code> \u2192 <code>R2 = R0</code> Puts the value of R0 into the passed in register operand SET R <code>0_1000_XXXX</code> <code>SET R1</code> \u2192 <code>R1 = 0xFF</code> set the value of R1 = 1111 1111 RESET R <code>0_1001_XXXX</code> <code>RESET R1</code> \u2192 <code>R1 = 0x00</code> reset the value of R1 = 0000 0000 LSL R <code>0_1010_XXXX</code> <code>LSL R1</code> \u2192 <code>R0 = R0 &lt;&lt; R1</code> left shift by value of R1 RSL R <code>0_1011_XXXX</code> <code>RSL R1</code> \u2192 <code>R0 = R0 &gt;&gt; R1</code> right shift by value of R1 ADDI I <code>11_000_XXXX</code> <code>ADDI 4</code> \u2192 <code>11_000_0100</code> \u2192 <code>R0 = R0 + 4</code> Performs add on value in register R0 and the immediate that is passed in and puts it into R0 SUBI I <code>11_001_XXXX</code> <code>SUBI 2</code> \u2192 <code>11_001_0010</code> \u2192 <code>R0 = R0 - 2</code> Performs sub on value in register R0 and the immediate that is passed in and puts it into R0 ANDI I <code>11_010_XXXX</code> <code>ANDI 5</code> \u2192 <code>11_010_0101</code> \u2192 <code>R0 = R0 &amp; 5</code> Performs a logical bitwise and on R0 and the inputted operand immediate and puts the result in R0 ORI I <code>11_011_XXXX</code> <code>ORI 6</code> \u2192 <code>11_011_0110</code> \u2192 <code>R0 = R0 \\| 6</code> Performs a logical bitwise or on R0 and the inputted operand immediate and puts the result in R0 MOVI I <code>11_100_XXXX</code> <code>MOVI 3</code> \u2192 <code>R0[3:0] = 3</code> set the lower 4 bits of R0 to the immediate value, preserve upper 4 bits LSLI I <code>11_101_XXXX</code> <code>LSLI 7</code> \u2192 <code>11_101_0111</code> \u2192 <code>R0 &lt;&lt;= 7</code> Performs a logical left shift on R0 by a specified immediate amount and puts that value into R0 RSLI I <code>11_110_XXXX</code> <code>RSLI 2</code> \u2192 <code>11_110_0010</code> \u2192 <code>R0 &gt;&gt;= 2</code> Performs a logical right shift on R0 by a specified immediate amount and puts that value into R0 DONE I <code>11_111_1111</code> <code>DONE</code> \u2192 <code>11_111_1111</code> Uses this instruction to indicate the end of assembly program BE J <code>10_00_X_XXXX</code> <code>BE R10</code> \u2192 <code>10_00_01010</code> Branch if equal: if R0 == operand, PC += 2, else PC += 1 BG J <code>10_01_X_XXXX</code> <code>BG Rx</code> \u2192 Skip next if R0 &gt; operand if true, PC += 2, if false, PC += 1 BL J <code>10_10_X_XXXX</code> <code>BL Rx</code> \u2192 Skip next if R0 &lt; operand if true, PC += 2, if false, PC += 1 J J <code>10_11_XXXXX</code> <code>J #location</code> \u2192 <code>10_11_10100</code> Performs a jump using JLUT: PC = JLUT[5-bit immediate]"},{"location":"architecture/memory/","title":"The Memory Map","text":""},{"location":"architecture/memory/#instruction-rom","title":"Instruction ROM","text":"<ul> <li>Where the compiled machine code is stored, populated from the <code>mach_code.txt</code> when loading the program.</li> <li>Since the program we need to run on this architecture is small, it is decided that <code>PC</code> will be 16 bits wide. This allows for a maximum of 65536 instructions, which is more than enough for our needs.</li> </ul>"},{"location":"architecture/memory/#data-ram","title":"Data RAM","text":""},{"location":"architecture/memory/#jump-lut-jlut","title":"Jump LUT (JLUT)","text":"<ul> <li>A small lookup table that holds the target addresses for jump instructions.</li> <li>Since the <code>Jmp (10_11_XXXXX)</code> instrction only have 5 bits for the immediate value, We can only jump to 32 different locations.</li> </ul>"},{"location":"verification/results/","title":"Simulation Results","text":""},{"location":"verification/results/#resource-usage","title":"Resource Usage","text":""},{"location":"verification/results/#fmax","title":"Fmax","text":"<p>the delay is approximately 1/117.15Mhz = 8.53ns</p> <p>The Area is is 398 ALUTs</p> <p>so the Area * delay is 398 * 8.53ns = 3397.94 ns*ALUTs</p>"},{"location":"verification/strategy/","title":"Hardware Verification Strategy","text":"<ul> <li>Unit test are done on each hardware components to ensure its functionality. for example:</li> </ul>"},{"location":"verification/strategy/#alu-unit-test","title":"ALU Unit Test","text":"<ul> <li>Then, some test scripts are written to test the entire datapath, for example:</li> </ul>"},{"location":"verification/strategy/#simple-control-flow-assembly-test-script","title":"Simple Control Flow Assembly Test Script:","text":"<ul> <li>scripts.ISA_tests.control_flow.sample_control_flow</li> <li>This script tests the control flow instructions such as BE, BG, BL, and J. It checks if the program counter (PC) is updated correctly based on the conditions specified in the instructions.</li> </ul> <pre><code>MOVI 0          // PC=1: Set R0 to 0\nMOV R10         // PC=2: R10 = 0 (Address for result in MEM[0])\nMOVI 2          // PC=3: Set R0 to 2\nMOV R12         // PC=4: R12 = 2 (Address for num1 in MEM[2])\nMOVI 3          // PC=5: Set R0 to 3\nMOV R13         // PC=6: R13 = 3 (Address for num2 in MEM[3])\nLOAD R12        // PC=7: R0 = DMem[R12] (Load byte from MEM[2] into R0)\nMOV R1          // PC=8: R1 = R0 (Move num1 from R0 to R1)\nLOAD R13        // PC=9: R0 = DMem[R13] (Load byte from MEM[3] into R0)\nMOV R2          // PC=10: R2 = R0 (Move num2 from R0 to R2)\nLOAD R12        // PC=11: R0 = DMem[R12] (Load num1 from MEM[2] into R0 for comparison)\nBG R2           // PC=12: Compare R0 (num1) &gt; R2 (num2).\nJ #SUB_PATH             // PC=13: J #SUB_PATH (Unconditionally jump to SUB_PATH if BG was FALSE)\nADD_PATH: LOAD R12        // PC=14: R0 = DMem[R12] (Load num1 into R0 again for addition)\nADD R2          // PC=15: R0 = R0 + R2 (R0 now holds num1 + num2)\nSTORE R10       // PC=16: DMem[R10] = R0 (Store the calculated sum into MEM[0])\nJ #END_PROGRAM             // PC=17: J #END_PROGRAM (Jump to end of program after addition)\nSUB_PATH: LOAD R12        // PC=18: R0 = DMem[R12] (Load num1 into R0 again for subtraction)\nSUB R2          // PC=19: R0 = R0 - R2 (R0 now holds num1 - num2)\nSTORE R10       // PC=20: DMem[R10] = R0 (Store the calculated difference into MEM[0])\nEND_PROGRAM: DONE            // PC=21: Signal the end of the program execution\n</code></pre> <p>Then use the custom assembler written in Python to convert this assembly code into machine code, JLUT, and initial DMEM</p> <pre><code>111000000\n001111010\n111000010\n001111100\n111000011\n001111101\n001001100\n001110001\n001001101\n001110010\n001001100\n100110001\n101100000\n001001100\n000100010\n001011010\n101100001\n001001100\n000110010\n001011010\n111111111\n</code></pre> <p>And verify the Result in the Modelsim</p>"}]}